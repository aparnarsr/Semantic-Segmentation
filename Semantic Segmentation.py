# -*- coding: utf-8 -*-
"""HW5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cazg5v6XUAc_n9Zps_Veqt9ASDCB6AoT
"""

import os 
import torch
import numpy as np
import torchvision 
from PIL import Image
import torch.nn as nn
import torch.optim as optim
from torchvision import models
import torch.nn.functional as F
from torchvision import transforms
from matplotlib import pyplot as plt
from torchvision.models.vgg import VGG
from sklearn.metrics import confusion_matrix
from torch.utils.data import DataLoader,Dataset

# Custom Tensor conversion

def converttotensor(img):
  im=np.array(img)
  im[im == 255] = 0
  return torch.tensor(im).long()

# Defining image transformations

imgtransformation=transforms.Compose([transforms.Resize((224,224)),transforms.ToTensor()])
labeltransformation=transforms.Compose([transforms.Resize((224,224)),converttotensor])

# Creating training and validation data objects

root=os.getcwd()

traindata = torchvision.datasets.VOCSegmentation(root, year='2012', image_set='train',
download= True , transform=imgtransformation, target_transform=labeltransformation, transforms=None)

validdata = torchvision.datasets.VOCSegmentation(root, year='2012', image_set='val',
download= True , transform=imgtransformation, target_transform=labeltransformation, transforms=None)

# Training and validation data loaders

trainloader=DataLoader(traindata,batch_size=5, shuffle=True, num_workers=4)
validloader=DataLoader(validdata,batch_size=5, shuffle=False, num_workers=4)

# Evaluation metrics

# Pixel-level IOU

def compute_iou(y_pred, y_true):
     y_pred = y_pred.cpu().flatten()
     y_true = y_true.cpu().flatten()
     cm = confusion_matrix(y_true, y_pred)
     tp=(np.diag(cm))
     fn=cm.sum(axis=0)-(np.diag(cm))
     fp=cm.sum(axis=1)-(np.diag(cm))     
     classiou=tp/(tp+fp+fn)
     finaliou=np.mean(classiou)
     return finaliou

# Dice Score

def compute_dice(y_pred, y_true):
     y_pred = y_pred.cpu().flatten()
     y_true = y_true.cpu().flatten()
     cm = confusion_matrix(y_true, y_pred)
     tp=(np.diag(cm))
     fn=cm.sum(axis=0)-(np.diag(cm))
     fp=cm.sum(axis=1)-(np.diag(cm))   
     classdice=(2*tp)/((2*tp)+fp+fn)
     finaldice=np.mean(classdice)
     return finaldice

# Color images

def decode_segmap(image, nc=21):
   
  label_colors = np.array([(0, 0, 0),  # 0=background
               # 1=aeroplane, 2=bicycle, 3=bird, 4=boat, 5=bottle
               (128, 0, 0), (0, 128, 0), (128, 128, 0), (0, 0, 128), (128, 0, 128),
               # 6=bus, 7=car, 8=cat, 9=chair, 10=cow
               (0, 128, 128), (128, 128, 128), (64, 0, 0), (192, 0, 0), (64, 128, 0),
               # 11=dining table, 12=dog, 13=horse, 14=motorbike, 15=person
               (192, 128, 0), (64, 0, 128), (192, 0, 128), (64, 128, 128), (192, 128, 128),
               # 16=potted plant, 17=sheep, 18=sofa, 19=train, 20=tv/monitor
               (0, 64, 0), (128, 64, 0), (0, 192, 0), (128, 192, 0), (0, 64, 128)])
 
  r = np.zeros_like(image).astype(np.uint8)
  g = np.zeros_like(image).astype(np.uint8)
  b = np.zeros_like(image).astype(np.uint8)
   
  for l in range(0, nc):
    idx = image == l
    r[idx] = label_colors[l, 0]
    g[idx] = label_colors[l, 1]
    b[idx] = label_colors[l, 2]
     
  rgb = np.stack([r, g, b], axis=2)
  return rgb

# FCN32s MODEL

class fcn32s(nn.Module):
  def __init__(self):
    super(fcn32s, self).__init__()
    vgg16=torchvision.models.vgg16(pretrained=True)
    self.convolutional=vgg16.features
    # Freeze model weights in vgg16
    for param in vgg16.parameters():
        param.requires_grad = False
    self.conv14=nn.Conv2d(512,4096, kernel_size=7)
    self.conv15=nn.Conv2d(4096,4096, kernel_size=1)
    self.conv16=nn.Conv2d(4096,21, kernel_size=1)
    self.deconv1=nn.ConvTranspose2d(21,21, kernel_size=224, stride=32)
    
  def forward(self,x):
    out=self.convolutional(x)
    out=F.relu(self.conv14(out))
    out=F.relu(self.conv15(out))
    out=F.relu(self.conv16(out))
    out=self.deconv1(out)
    return out

# Training of FCN32s Model

model=fcn32s()
device = torch.device('cuda')
model.to(device)
loss_func = torch.nn.CrossEntropyLoss() 
optimization = torch.optim.Adam(model.parameters(), lr = 0.0001)

trainlosslist=[]
validlosslist=[]
epochs=[]
epochiou=[]
epochdice=[]
epochvalidiou=[]
epochvaliddice=[]
numEpochs = 20
for epoch in range(1,numEpochs+1):
    print("epoch ", epoch)
    batchiou=[]
    batchvalidiou=[]
    batchdice=[]
    batchvaliddice=[]
    epoch_training_loss=0.0
    num_batches = 0
    for batch_num, training_batch in enumerate(trainloader): 
        inputs, labels = training_batch   
        inputs=inputs.to(device)  
        labels=labels.to(device)  
        optimization.zero_grad()         
        forward_output = model(inputs)
        loss = loss_func(forward_output, labels)
        loss.backward()   
        optimization.step() 
        epoch_training_loss += loss.item()
        num_batches += 1
        _, predicted = torch.max(forward_output, 1)
        if batch_num%200==0:
          print(" batch number: ",batch_num," loss: ",loss.item())
        dice=[]
        iou=[]
        for i in range(len(inputs)):
          iou.append(compute_iou(predicted[i],labels[i]))
          dice.append(compute_dice(predicted[i],labels[i]))
        batchiou.append(np.mean(iou))
        batchdice.append(np.mean(dice))
    
    plt.imshow(np.array(np.transpose(inputs[0].cpu(),(1,2,0))))
    plt.show()
    plt.imshow(decode_segmap(np.array((labels[0].cpu()))))
    plt.show()
    plt.imshow(decode_segmap(np.array((predicted[0].cpu()))))
    plt.show()

    epochiou.append(np.mean(batchiou))
    epochdice.append(np.mean(batchdice))
    print("training iou ", np.mean(batchiou))
    print("training dice ", np.mean(batchdice))
    print("training loss: ", epoch_training_loss/num_batches) 
    trainlosslist.append(epoch_training_loss/num_batches)

    epoch_validation_loss=0.0
    num_batches = 0
    with torch.no_grad():
      for data in validloader:
        inputs, labels = data
        inputs=inputs.to(device)  
        labels=labels.to(device)
        outputs = model(inputs)
        loss=loss_func(outputs, labels)
        epoch_validation_loss += loss.item()
        num_batches += 1
        _, predicted = torch.max(outputs.data, 1)
        validiou=[]
        validdice=[]
        for i in range(len(inputs)):
          validiou.append(compute_iou(predicted[i],labels[i]))
          validdice.append(compute_dice(predicted[i],labels[i]))
        batchvalidiou.append(np.mean(validiou))
        batchvaliddice.append(np.mean(validdice))
    epochvalidiou.append(np.mean(batchvalidiou))
    epochvaliddice.append(np.mean(batchvaliddice))
    print("validation iou ", np.mean(batchvalidiou))
    print("validation dice ", np.mean(batchvaliddice))
    print("validation loss: ", epoch_validation_loss/num_batches)
    validlosslist.append(epoch_validation_loss/num_batches)
    epochs.append(epoch)

# Plotting FCN32s losses for training and validation

plt.plot(epochs, validlosslist, color='red')
plt.plot(epochs, trainlosslist, color='green')
plt.title('Model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()

# Plotting FCN32s Pixel-level IOU results for training and validation

plt.plot(epochs, epochvalidiou, color='blue')
plt.plot(epochs, epochiou, color='yellow')
plt.title('Model pixel-level IoU')
plt.ylabel('Pixel-level IoU')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()

# Plotting FCN32s DICE Score results for training and validation

plt.plot(epochs, epochvaliddice, color='blue')
plt.plot(epochs, epochdice, color='yellow')
plt.title('Model DICE Score')
plt.ylabel('DICE Scores')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()

# FCN16s MODEL

class fcn16s(nn.Module):
  def __init__(self):
    super(fcn16s, self).__init__()
    vgg16=torchvision.models.vgg16(pretrained=True)
    self.convolutional=vgg16.features
    # Freeze model weights in vgg16
    for param in vgg16.parameters():
        param.requires_grad = False
    self.conv14=nn.Conv2d(512,4096, kernel_size=7)
    self.conv15=nn.Conv2d(4096,4096, kernel_size=1)
    self.conv16=nn.Conv2d(4096,21, kernel_size=1)
    self.mp=nn.Conv2d(512,21,kernel_size=1)
    self.deconv1=nn.ConvTranspose2d(21,21, kernel_size=14, stride=2)
    self.deconv2=nn.ConvTranspose2d(21,21,kernel_size=16,stride=16)
    self.convolutional[23].register_forward_hook(self.output_saving_hook)
    
  def forward(self,x):
    outmp5=self.convolutional(x)
    outmp5=F.relu(self.conv14(outmp5))
    outmp5=F.relu(self.conv15(outmp5))
    outmp5=F.relu(self.conv16(outmp5))
    outmp5=self.deconv1(outmp5)

    outmp4=F.relu(self.mp(self.forwardoutput))
    
    out=torch.add(outmp4,outmp5)
    out=self.deconv2(out)

    return out

  def output_saving_hook(self,module, input, output):
    self.forwardoutput=output

# Training of FCN16s Model

model2=fcn16s()
device = torch.device('cuda')
model2.to(device)
loss_func = torch.nn.CrossEntropyLoss() 
optimization = torch.optim.Adam(model2.parameters(), lr = 0.0001)

trainlosslist=[]
validlosslist=[]
epochs=[]
epochiou=[]
epochdice=[]
epochvalidiou=[]
epochvaliddice=[]
numEpochs = 20
for epoch in range(1,numEpochs+1):
    print("epoch ", epoch)
    batchiou=[]
    batchvalidiou=[]
    batchdice=[]
    batchvaliddice=[]
    epoch_training_loss=0.0
    num_batches = 0
    for batch_num, training_batch in enumerate(trainloader): 
        inputs, labels = training_batch   
        inputs=inputs.to(device)  
        labels=labels.to(device)  
        optimization.zero_grad()         
        forward_output = model2(inputs)
        loss = loss_func(forward_output, labels)
        loss.backward()   
        optimization.step() 
        epoch_training_loss += loss.item()
        num_batches += 1
        _, predicted = torch.max(forward_output, 1)
        if batch_num%200==0:
          print(" batch number: ",batch_num," loss: ",loss.item())
        dice=[]
        iou=[]
        for i in range(len(inputs)):
          iou.append(compute_iou(predicted[i],labels[i]))
          dice.append(compute_dice(predicted[i],labels[i]))
        batchiou.append(np.mean(iou))
        batchdice.append(np.mean(dice))
    
    plt.imshow(np.array(np.transpose(inputs[0].cpu(),(1,2,0))))
    plt.show()
    plt.imshow(decode_segmap(np.array((labels[0].cpu()))))
    plt.show()
    plt.imshow(decode_segmap(np.array((predicted[0].cpu()))))
    plt.show()

    epochiou.append(np.mean(batchiou))
    epochdice.append(np.mean(batchdice))
    print("training iou ", np.mean(batchiou))
    print("training dice ", np.mean(batchdice))
    print("training loss: ", epoch_training_loss/num_batches) 
    trainlosslist.append(epoch_training_loss/num_batches)

    epoch_validation_loss=0.0
    num_batches = 0
    with torch.no_grad():
      for data in validloader:
        inputs, labels = data
        inputs=inputs.to(device)  
        labels=labels.to(device)
        outputs = model2(inputs)
        loss=loss_func(outputs, labels)
        epoch_validation_loss += loss.item()
        num_batches += 1
        _, predicted = torch.max(outputs.data, 1)
        validiou=[]
        validdice=[]
        for i in range(len(inputs)):
          validiou.append(compute_iou(predicted[i],labels[i]))
          validdice.append(compute_dice(predicted[i],labels[i]))
        batchvalidiou.append(np.mean(validiou))
        batchvaliddice.append(np.mean(validdice))
    epochvalidiou.append(np.mean(batchvalidiou))
    epochvaliddice.append(np.mean(batchvaliddice))
    print("validation iou ", np.mean(batchvalidiou))
    print("validation dice ", np.mean(batchvaliddice))
    print("validation loss: ", epoch_validation_loss/num_batches)
    validlosslist.append(epoch_validation_loss/num_batches)
    epochs.append(epoch)

# Plotting FCN16s losses for training and validation

plt.plot(epochs, validlosslist, color='red')
plt.plot(epochs, trainlosslist, color='green')
plt.title('Model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()

# Plotting FCN16s Pixel-level IOU results for training and validation

plt.plot(epochs, epochvalidiou, color='blue')
plt.plot(epochs, epochiou, color='yellow')
plt.title('Model pixel-level IoU')
plt.ylabel('Pixel-level IoU')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()

# Plotting FCN16s DICE Score results for training and validation

plt.plot(epochs, epochvaliddice, color='blue')
plt.plot(epochs, epochdice, color='yellow')
plt.title('Model DICE Score')
plt.ylabel('DICE Scores')
plt.xlabel('epoch')
plt.legend(['validation', 'train'], loc='upper left')
plt.plot()